using BlazorHybridMsalAuth.Config;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using Microsoft.Identity.Client;
using Microsoft.Identity.Client.Extensions.Msal;
using Microsoft.IdentityModel.Abstractions;
using System.Diagnostics;
using System.Security.Claims;

#if WINDOWS
using Microsoft.Identity.Client.Desktop;
#endif

namespace BlazorHybridMsalAuth.Services;

/// <summary>
/// Contains methods that initialize and use the MSAL SDK
/// </summary>
public class MSALClientHelper
{
    /// <summary>
    /// As for the Tenant, you can use a name as obtained from the azure portal, e.g. kko365.onmicrosoft.com"
    /// </summary>
    public AzureAdConfig AzureAdConfig { get; }

    private readonly ILogger<MSALClientHelper> _logger;

    private AuthenticationResult _authResult;

    /// <summary>
    /// Gets the authentication result (if available) from MSAL's various operations.
    /// </summary>
    /// <value>
    /// The authentication result.
    /// </value>
    public AuthenticationResult AuthResult
    {
        get => _authResult;
        set
        {
            var userChanged = false;
            if (value.ClaimsPrincipal != _authResult?.ClaimsPrincipal)
            {
                userChanged = true;
            }

            _authResult = value;

            if (userChanged)
            {
                UserChanged?.Invoke(this, new UserChangedEventArgs(value.ClaimsPrincipal));
            }
        }
    }

    public event EventHandler<UserChangedEventArgs> UserChanged;

    /// <summary>
    /// Gets the MSAL public client application instance.
    /// </summary>
    /// <value>
    /// The public client application.
    /// </value>
    public IPublicClientApplication PublicClientApplication { get; private set; }

    /// <summary>
    /// This will determine if the Interactive Authentication should be Embedded or System view
    /// </summary>
    public bool UseEmbedded { get; set; } = false;

    /// <summary>
    /// The claims principal of the last logged in user.
    /// </summary>
    public ClaimsPrincipal? CurrentUser => AuthResult?.ClaimsPrincipal;

    /// <summary>
    /// The PublicClientApplication builder used internally
    /// </summary>
    private PublicClientApplicationBuilder PublicClientApplicationBuilder;

    // Token Caching setup - Mac
    public static readonly string KeyChainServiceName = "BlazorHybridMsalAuth";

    public static readonly string KeyChainAccountName = "MSALCache";

    public static readonly KeyValuePair<string, string> LinuxKeyRingAttr2 = new KeyValuePair<string, string>("ProductGroup", "BlazorHybridMsalAuth");

    private static string PCANotInitializedExceptionMessage = "The PublicClientApplication needs to be initialized before calling this method. Use InitializePublicClientAppAsync() to initialize.";

    /// <summary>
    /// Initializes a new instance of the <see cref="MSALClientHelper"/> class.
    /// </summary>
    public MSALClientHelper(IOptions<AzureAdConfig> azureAdConfig, ILogger<MSALClientHelper> logger)
    {
        _logger = logger;
        AzureAdConfig = azureAdConfig.Value;

        InitializePublicClientApplicationBuilder();
    }

    /// <summary>
    /// Initializes the MSAL's PublicClientApplication builder from config.
    /// </summary>
    /// <autogeneratedoc />
    private void InitializePublicClientApplicationBuilder()
    {
        PublicClientApplicationBuilder = PublicClientApplicationBuilder.Create(AzureAdConfig.ClientId)
            .WithExperimentalFeatures() // this is for upcoming logger
            .WithAuthority(AzureCloudInstance.AzurePublic, AzureAdConfig.TenantId)
            .WithLogging(new IdentityLogger(EventLogLevel.Warning), enablePiiLogging: false)    // This is the currently recommended way to log MSAL message. For more info refer to https://github.com/AzureAD/microsoft-authentication-library-for-dotnet/wiki/logging. Set Identity Logging level to Warning which is a middle ground
            .WithIosKeychainSecurityGroup("com.microsoft.adalcache");
    }

    /// <summary>
    /// Initializes the public client application of MSAL.NET with the required information to correctly authenticate the user.
    /// </summary>
    /// <returns></returns>
    public void InitializePublicClientApp()
    {
        // Initialize the MSAL library by building a public client application
        PublicClientApplication = PublicClientApplicationBuilder
            .WithAuthority(AzureCloudInstance.AzurePublic, AzureAdConfig.TenantId)
            .WithRedirectUri($"msal{AzureAdConfig.ClientId}://auth")
#if WINDOWS
            .WithWindowsEmbeddedBrowserSupport()
            .WithCacheOptions(CacheOptions.EnableSharedCacheOptions)
#endif
            .Build();
    }

    /// <summary>
    /// Attaches the token cache to the Public Client app.
    /// </summary>
    /// <returns>IAccount list of already signed-in users (if available)</returns>
    private async Task<IEnumerable<IAccount>?> AttachTokenCache()
    {
        if (DeviceInfo.Current.Platform != DevicePlatform.WinUI)
        {
            return null;
        }

        // Cache configuration and hook-up to public application. Refer to https://github.com/AzureAD/microsoft-authentication-extensions-for-dotnet/wiki/Cross-platform-Token-Cache#configuring-the-token-cache
        var storageProperties = new StorageCreationPropertiesBuilder("TokenCache.cache", Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), "ParaMeter"))
                .Build();

        var msalcachehelper = await MsalCacheHelper.CreateAsync(storageProperties);
        msalcachehelper.RegisterCache(PublicClientApplication.UserTokenCache);

        // If the cache file is being reused, we'd find some already-signed-in accounts
        return await PublicClientApplication.GetAccountsAsync().ConfigureAwait(false);
    }

    /// <summary>
    /// Signs in the user and obtains an Access token for a provided set of scopes
    /// </summary>
    /// <param name="scopes"></param>
    /// <returns> Access Token</returns>
    public async Task<string?> SignInUserAndAcquireAccessToken(string[] scopes, SilentLoginFailedAction silentFailedAction = SilentLoginFailedAction.ShowUI)
    {
        if (PublicClientApplication == null)
        {
            throw new NullReferenceException(PCANotInitializedExceptionMessage);
        }

        var existingUser = await FetchSignedInUserFromCache().ConfigureAwait(false);

        try
        {
            // 1. Try to sign-in the previously signed-in account
            if (existingUser != null)
            {
                _logger?.LogInformation($"Existing user found: {existingUser.Username}, attempting to login as existing user.");
                AuthResult = await PublicClientApplication
                    .AcquireTokenSilent(scopes, existingUser)
                    .ExecuteAsync()
                    .ConfigureAwait(false);
            }
            else
            {
                _logger?.LogInformation("Existing user not found.");
                switch (silentFailedAction)
                {
                    case SilentLoginFailedAction.ReturnNull:
                        return null;

                    case SilentLoginFailedAction.Throw:
                        throw new MsalUiRequiredException("6969", "Could not find existing user in cache.");
                    case SilentLoginFailedAction.ShowUI:
                        AuthResult = await SignInUserInteractivelyAsync(scopes);
                        break;
                }
            }
        }
        catch (MsalUiRequiredException ex) when (silentFailedAction != SilentLoginFailedAction.Throw)
        {
            if (silentFailedAction == SilentLoginFailedAction.ReturnNull)
            {
                return null;
            }
            else if (silentFailedAction == SilentLoginFailedAction.ShowUI)
            {
                // A MsalUiRequiredException happened on AcquireTokenSilentAsync. This indicates you need to call AcquireTokenInteractive to acquire a token interactively
                _logger?.LogInformation(ex, "MsalUiRequiredException handled as silentFailedAction is ShowUI.");

                AuthResult = await PublicClientApplication
                    .AcquireTokenInteractive(scopes)
                    .WithParentActivityOrWindow(PlatformConfig.Instance.ParentWindow)
                    .ExecuteAsync()
                    .ConfigureAwait(false);
            }
            else
            {
                throw new Exception("Unknown edge-case");
            }
        }
        catch (MsalException msalEx) when (silentFailedAction != SilentLoginFailedAction.Throw)
        {
            _logger?.LogError(msalEx, $"Error acquiring token interactively.");
            return null;
        }

        return AuthResult.AccessToken;
    }

    /// <summary>
    /// Signs the in user and acquire access token for a provided set of scopes.
    /// </summary>
    /// <param name="scopes">The scopes.</param>
    /// <param name="extraclaims">The extra claims, usually from CAE. We basically handle CAE by sending the user back to Azure AD for
    /// additional processing and requesting a new access token for Graph</param>
    /// <returns></returns>
    public async Task<string> SignInUserAndAcquireAccessToken(string[] scopes, string extraclaims)
    {
        if (PublicClientApplication == null)
        {
            throw new NullReferenceException(PCANotInitializedExceptionMessage);
        }

        try
        {
            // Send the user to Azure AD for re-authentication as a silent acquisition wont resolve any CAE scenarios like an extra claims request
            AuthResult = await PublicClientApplication.AcquireTokenInteractive(scopes)
                    .WithClaims(extraclaims)
                    .ExecuteAsync()
                    .ConfigureAwait(false);
        }
        catch (MsalException msalEx)
        {
            _logger?.LogError(msalEx, "Error aquiring token.");
        }

        return AuthResult.AccessToken;
    }

    /// <summary>
    /// Shows a pattern to sign-in a user interactively in applications that are input constrained and would need to fall-back on device code flow.
    /// </summary>
    /// <param name="scopes">The scopes.</param>
    /// <param name="existingAccount">The existing account.</param>
    /// <returns></returns>
    public async Task<AuthenticationResult> SignInUserInteractivelyAsync(string[] scopes, IAccount existingAccount = null)
    {
        if (PublicClientApplication == null)
        {
            throw new NullReferenceException(PCANotInitializedExceptionMessage);
        }

        if (PublicClientApplication.IsUserInteractive())
        {
            return AuthResult = await PublicClientApplication.AcquireTokenInteractive(scopes)
                .WithParentActivityOrWindow(PlatformConfig.Instance.ParentWindow)
                .ExecuteAsync()
                .ConfigureAwait(false);
        }

        // If the operating system does not have UI (e.g. SSH into Linux), you can fallback to device code, however this
        // flow will not satisfy the "device is managed" CA policy.
        return AuthResult = await PublicClientApplication.AcquireTokenWithDeviceCode(scopes, (dcr) =>
        {
            Console.WriteLine(dcr.Message);
            return Task.CompletedTask;
        }).ExecuteAsync().ConfigureAwait(false);
    }

    /// <summary>
    /// Removes the first signed-in user's record from token cache
    /// </summary>
    public async Task SignOutUserAsync()
    {
        var existingUser = await FetchSignedInUserFromCache().ConfigureAwait(false);
        await SignOutUserAsync(existingUser).ConfigureAwait(false);
    }

    /// <summary>
    /// Removes a given user's record from token cache
    /// </summary>
    /// <param name="user">The user.</param>
    public async Task SignOutUserAsync(IAccount user)
    {
        if (PublicClientApplication == null)
            return;

        _logger?.LogInformation($"Signing out user account {user.Username}");
        await PublicClientApplication.RemoveAsync(user).ConfigureAwait(false);
    }

    /// <summary>
    /// Fetches the signed in user from MSAL's token cache (if available).
    /// </summary>
    /// <returns></returns>
    public async Task<IAccount?> FetchSignedInUserFromCache()
    {
        if (PublicClientApplication == null)
        {
            throw new NullReferenceException(PCANotInitializedExceptionMessage);
        }

        // get accounts from cache
        IEnumerable<IAccount> accounts = await PublicClientApplication.GetAccountsAsync();

        // Error corner case: we should always have 0 or 1 accounts, not expecting > 1
        // This is just an example of how to resolve this ambiguity, which can arise if more apps share a token cache.
        // Note that some apps prefer to use a random account from the cache.
        if (accounts.Count() > 1)
        {
            _logger?.LogInformation("Too many accounts in the cache, removing them.");
            foreach (var acc in accounts)
            {
                await PublicClientApplication.RemoveAsync(acc);
            }

            return null;
        }

        return accounts.SingleOrDefault();
    }
}

public class UserChangedEventArgs
{
    public ClaimsPrincipal NewUser { get; }

    public UserChangedEventArgs(ClaimsPrincipal value)
    {
        NewUser = value;
    }
}

public enum SilentLoginFailedAction
{
    ReturnNull,
    Throw,
    ShowUI
}

/// <summary>
/// Platform specific configuration.
/// </summary>
public class PlatformConfig
{
    /// <summary>
    /// Instance to store data
    /// </summary>
    public static PlatformConfig Instance { get; } = new PlatformConfig();

    /// <summary>
    /// Platform specific parent window
    /// </summary>
    public object ParentWindow { get; set; }

    // private constructor to ensure singleton
    private PlatformConfig()
    {
    }
}